{"ast":null,"code":"'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { useRef, useCallback } from 'react';\nimport omit from 'lodash/omit';\nimport set from 'lodash/set';\nimport { useControlled, useEventCallback } from \"../../internals/hooks/index.js\";\nimport { nameToPath } from \"../../FormControl/utils.js\";\nexport default function useFormValidate(_formError, props) {\n  var formValue = props.formValue,\n    getCombinedModel = props.getCombinedModel,\n    onCheck = props.onCheck,\n    onError = props.onError,\n    nestedField = props.nestedField;\n  var _useControlled = useControlled(_formError, {}),\n    realFormError = _useControlled[0],\n    setFormError = _useControlled[1];\n  var checkOptions = {\n    nestedObject: nestedField\n  };\n  var realFormErrorRef = useRef(realFormError);\n  realFormErrorRef.current = realFormError;\n\n  /**\n   * Validate the form data and return a boolean.\n   * The error message after verification is returned in the callback.\n   * @param callback\n   */\n  var check = useEventCallback(function (callback) {\n    var formError = {};\n    var errorCount = 0;\n    var model = getCombinedModel();\n    var checkField = function checkField(key, type, value, formErrorObj) {\n      model.setSchemaOptionsForAllType(formValue || {});\n      var checkResult = type.check(value, formValue, key);\n      if (checkResult.hasError === true) {\n        errorCount += 1;\n        formErrorObj[key] = (checkResult === null || checkResult === void 0 ? void 0 : checkResult.errorMessage) || checkResult;\n      }\n\n      // Check nested object\n      if (type !== null && type !== void 0 && type.objectTypeSchemaSpec) {\n        Object.entries(type.objectTypeSchemaSpec).forEach(function (_ref) {\n          var nestedKey = _ref[0],\n            nestedType = _ref[1];\n          formErrorObj[key] = formErrorObj[key] || {\n            object: {}\n          };\n          checkField(nestedKey, nestedType, value === null || value === void 0 ? void 0 : value[nestedKey], formErrorObj[key].object);\n        });\n      }\n    };\n    Object.entries(model.getSchemaSpec()).forEach(function (_ref2) {\n      var key = _ref2[0],\n        type = _ref2[1];\n      checkField(key, type, formValue[key], formError);\n    });\n    setFormError(formError);\n    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);\n    callback === null || callback === void 0 ? void 0 : callback(formError);\n    if (errorCount > 0) {\n      onError === null || onError === void 0 ? void 0 : onError(formError);\n      return false;\n    }\n    return true;\n  });\n  var checkFieldForNextValue = useEventCallback(function (fieldName, nextValue, callback) {\n    var model = getCombinedModel();\n    var resultOfCurrentField = model.checkForField(fieldName, nextValue, checkOptions);\n    var nextFormError = _extends({}, realFormError);\n    /**\n     * when using proxy of schema-typed, we need to use getCheckResult to get all errors,\n     * but if nestedField is used, it is impossible to distinguish whether the nested object has an error here,\n     * so nestedField does not support proxy here\n     */\n    if (nestedField) {\n      nextFormError = set(nextFormError, nameToPath(fieldName), resultOfCurrentField);\n      setFormError(nextFormError);\n      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n      callback === null || callback === void 0 ? void 0 : callback(resultOfCurrentField);\n      if (resultOfCurrentField.hasError) {\n        onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n      }\n      return !resultOfCurrentField.hasError;\n    } else {\n      var allResults = model.getCheckResult();\n      var hasError = false;\n      Object.keys(allResults).forEach(function (key) {\n        var currentResult = allResults[key];\n        if (currentResult.hasError) {\n          nextFormError[key] = currentResult.errorMessage || currentResult;\n          hasError = true;\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          var _nextFormError = nextFormError,\n            _ = _nextFormError[key],\n            rest = _objectWithoutPropertiesLoose(_nextFormError, [key].map(_toPropertyKey));\n          nextFormError = rest;\n        }\n      });\n      setFormError(nextFormError);\n      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n      callback === null || callback === void 0 ? void 0 : callback(resultOfCurrentField);\n      if (hasError) {\n        onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n      }\n      return !hasError;\n    }\n  });\n  /**\n   * Check the data field\n   * @param fieldName\n   * @param callback\n   */\n  var checkForField = useEventCallback(function (fieldName, callback) {\n    return checkFieldForNextValue(fieldName, formValue || {}, callback);\n  });\n\n  /**\n   * Check form data asynchronously and return a Promise\n   */\n  var checkAsync = useEventCallback(function () {\n    var promises = [];\n    var keys = [];\n    var model = getCombinedModel();\n    Object.keys(model.getSchemaSpec()).forEach(function (key) {\n      keys.push(key);\n      promises.push(model.checkForFieldAsync(key, formValue || {}, checkOptions));\n    });\n    return Promise.all(promises).then(function (values) {\n      var formError = {};\n      var errorCount = 0;\n      for (var i = 0; i < values.length; i++) {\n        if (values[i].hasError) {\n          errorCount += 1;\n          formError[keys[i]] = values[i].errorMessage;\n        }\n      }\n      onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);\n      setFormError(formError);\n      if (errorCount > 0) {\n        onError === null || onError === void 0 ? void 0 : onError(formError);\n      }\n      return {\n        hasError: errorCount > 0,\n        formError: formError\n      };\n    });\n  });\n  var checkFieldAsyncForNextValue = useEventCallback(function (fieldName, nextValue) {\n    var model = getCombinedModel();\n    return model.checkForFieldAsync(fieldName, nextValue, checkOptions).then(function (resultOfCurrentField) {\n      var nextFormError = _extends({}, realFormError);\n      /**\n       * when using proxy of schema-typed, we need to use getCheckResult to get all errors,\n       * but if nestedField is used, it is impossible to distinguish whether the nested object has an error here,\n       * so nestedField does not support proxy here\n       */\n\n      if (nestedField) {\n        nextFormError = set(nextFormError, nameToPath(fieldName), resultOfCurrentField);\n        onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n        setFormError(nextFormError);\n        if (resultOfCurrentField.hasError) {\n          onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n        }\n        return resultOfCurrentField;\n      } else {\n        var allResults = model.getCheckResult();\n        var hasError = false;\n        Object.keys(allResults).forEach(function (key) {\n          var currentResult = allResults[key];\n          if (currentResult.hasError) {\n            nextFormError[key] = currentResult.errorMessage || currentResult;\n            hasError = true;\n          } else {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            var _nextFormError2 = nextFormError,\n              _ = _nextFormError2[key],\n              rest = _objectWithoutPropertiesLoose(_nextFormError2, [key].map(_toPropertyKey));\n            nextFormError = rest;\n          }\n        });\n        setFormError(nextFormError);\n        onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n        if (hasError) {\n          onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n        }\n        return resultOfCurrentField;\n      }\n    });\n  });\n\n  /**\n   * Asynchronously check form fields and return Promise\n   * @param fieldName\n   */\n  var checkForFieldAsync = useEventCallback(function (fieldName) {\n    return checkFieldAsyncForNextValue(fieldName, formValue || {});\n  });\n  var onRemoveError = useCallback(function (name) {\n    /**\n     * when this function is called when the children component is unmount,\n     * it's an old render frame so use Ref to get future error\n     */\n    var formError = omit(realFormErrorRef.current, [nestedField ? nameToPath(name) : name]);\n    realFormErrorRef.current = formError;\n    setFormError(formError);\n    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);\n    return formError;\n  }, [nestedField, onCheck, setFormError]);\n  var cleanErrors = useEventCallback(function () {\n    setFormError({});\n  });\n  var resetErrors = useEventCallback(function (formError) {\n    if (formError === void 0) {\n      formError = {};\n    }\n    setFormError(formError);\n  });\n  var cleanErrorForField = useEventCallback(function (fieldName) {\n    setFormError(omit(realFormError, [nestedField ? nameToPath(fieldName) : fieldName]));\n  });\n  return {\n    formError: realFormError,\n    check: check,\n    checkForField: checkForField,\n    checkFieldForNextValue: checkFieldForNextValue,\n    checkAsync: checkAsync,\n    checkForFieldAsync: checkForFieldAsync,\n    checkFieldAsyncForNextValue: checkFieldAsyncForNextValue,\n    cleanErrors: cleanErrors,\n    resetErrors: resetErrors,\n    cleanErrorForField: cleanErrorForField,\n    onRemoveError: onRemoveError\n  };\n}","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_toPropertyKey","t","i","_toPrimitive","r","e","Symbol","toPrimitive","call","TypeError","String","Number","useRef","useCallback","omit","set","useControlled","useEventCallback","nameToPath","useFormValidate","_formError","props","formValue","getCombinedModel","onCheck","onError","nestedField","_useControlled","realFormError","setFormError","checkOptions","nestedObject","realFormErrorRef","current","check","callback","formError","errorCount","model","checkField","key","type","value","formErrorObj","setSchemaOptionsForAllType","checkResult","hasError","errorMessage","objectTypeSchemaSpec","Object","entries","forEach","_ref","nestedKey","nestedType","object","getSchemaSpec","_ref2","checkFieldForNextValue","fieldName","nextValue","resultOfCurrentField","checkForField","nextFormError","allResults","getCheckResult","keys","currentResult","_nextFormError","_","rest","map","checkAsync","promises","push","checkForFieldAsync","Promise","all","then","values","length","checkFieldAsyncForNextValue","_nextFormError2","onRemoveError","name","cleanErrors","resetErrors","cleanErrorForField"],"sources":["/home/gabriel/Documents/formulario-change/node_modules/rsuite/esm/Form/hooks/useFormValidate.js"],"sourcesContent":["'use client';\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { useRef, useCallback } from 'react';\nimport omit from 'lodash/omit';\nimport set from 'lodash/set';\nimport { useControlled, useEventCallback } from \"../../internals/hooks/index.js\";\nimport { nameToPath } from \"../../FormControl/utils.js\";\nexport default function useFormValidate(_formError, props) {\n  var formValue = props.formValue,\n    getCombinedModel = props.getCombinedModel,\n    onCheck = props.onCheck,\n    onError = props.onError,\n    nestedField = props.nestedField;\n  var _useControlled = useControlled(_formError, {}),\n    realFormError = _useControlled[0],\n    setFormError = _useControlled[1];\n  var checkOptions = {\n    nestedObject: nestedField\n  };\n  var realFormErrorRef = useRef(realFormError);\n  realFormErrorRef.current = realFormError;\n\n  /**\n   * Validate the form data and return a boolean.\n   * The error message after verification is returned in the callback.\n   * @param callback\n   */\n  var check = useEventCallback(function (callback) {\n    var formError = {};\n    var errorCount = 0;\n    var model = getCombinedModel();\n    var checkField = function checkField(key, type, value, formErrorObj) {\n      model.setSchemaOptionsForAllType(formValue || {});\n      var checkResult = type.check(value, formValue, key);\n      if (checkResult.hasError === true) {\n        errorCount += 1;\n        formErrorObj[key] = (checkResult === null || checkResult === void 0 ? void 0 : checkResult.errorMessage) || checkResult;\n      }\n\n      // Check nested object\n      if (type !== null && type !== void 0 && type.objectTypeSchemaSpec) {\n        Object.entries(type.objectTypeSchemaSpec).forEach(function (_ref) {\n          var nestedKey = _ref[0],\n            nestedType = _ref[1];\n          formErrorObj[key] = formErrorObj[key] || {\n            object: {}\n          };\n          checkField(nestedKey, nestedType, value === null || value === void 0 ? void 0 : value[nestedKey], formErrorObj[key].object);\n        });\n      }\n    };\n    Object.entries(model.getSchemaSpec()).forEach(function (_ref2) {\n      var key = _ref2[0],\n        type = _ref2[1];\n      checkField(key, type, formValue[key], formError);\n    });\n    setFormError(formError);\n    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);\n    callback === null || callback === void 0 ? void 0 : callback(formError);\n    if (errorCount > 0) {\n      onError === null || onError === void 0 ? void 0 : onError(formError);\n      return false;\n    }\n    return true;\n  });\n  var checkFieldForNextValue = useEventCallback(function (fieldName, nextValue, callback) {\n    var model = getCombinedModel();\n    var resultOfCurrentField = model.checkForField(fieldName, nextValue, checkOptions);\n    var nextFormError = _extends({}, realFormError);\n    /**\n     * when using proxy of schema-typed, we need to use getCheckResult to get all errors,\n     * but if nestedField is used, it is impossible to distinguish whether the nested object has an error here,\n     * so nestedField does not support proxy here\n     */\n    if (nestedField) {\n      nextFormError = set(nextFormError, nameToPath(fieldName), resultOfCurrentField);\n      setFormError(nextFormError);\n      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n      callback === null || callback === void 0 ? void 0 : callback(resultOfCurrentField);\n      if (resultOfCurrentField.hasError) {\n        onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n      }\n      return !resultOfCurrentField.hasError;\n    } else {\n      var allResults = model.getCheckResult();\n      var hasError = false;\n      Object.keys(allResults).forEach(function (key) {\n        var currentResult = allResults[key];\n        if (currentResult.hasError) {\n          nextFormError[key] = currentResult.errorMessage || currentResult;\n          hasError = true;\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          var _nextFormError = nextFormError,\n            _ = _nextFormError[key],\n            rest = _objectWithoutPropertiesLoose(_nextFormError, [key].map(_toPropertyKey));\n          nextFormError = rest;\n        }\n      });\n      setFormError(nextFormError);\n      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n      callback === null || callback === void 0 ? void 0 : callback(resultOfCurrentField);\n      if (hasError) {\n        onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n      }\n      return !hasError;\n    }\n  });\n  /**\n   * Check the data field\n   * @param fieldName\n   * @param callback\n   */\n  var checkForField = useEventCallback(function (fieldName, callback) {\n    return checkFieldForNextValue(fieldName, formValue || {}, callback);\n  });\n\n  /**\n   * Check form data asynchronously and return a Promise\n   */\n  var checkAsync = useEventCallback(function () {\n    var promises = [];\n    var keys = [];\n    var model = getCombinedModel();\n    Object.keys(model.getSchemaSpec()).forEach(function (key) {\n      keys.push(key);\n      promises.push(model.checkForFieldAsync(key, formValue || {}, checkOptions));\n    });\n    return Promise.all(promises).then(function (values) {\n      var formError = {};\n      var errorCount = 0;\n      for (var i = 0; i < values.length; i++) {\n        if (values[i].hasError) {\n          errorCount += 1;\n          formError[keys[i]] = values[i].errorMessage;\n        }\n      }\n      onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);\n      setFormError(formError);\n      if (errorCount > 0) {\n        onError === null || onError === void 0 ? void 0 : onError(formError);\n      }\n      return {\n        hasError: errorCount > 0,\n        formError: formError\n      };\n    });\n  });\n  var checkFieldAsyncForNextValue = useEventCallback(function (fieldName, nextValue) {\n    var model = getCombinedModel();\n    return model.checkForFieldAsync(fieldName, nextValue, checkOptions).then(function (resultOfCurrentField) {\n      var nextFormError = _extends({}, realFormError);\n      /**\n       * when using proxy of schema-typed, we need to use getCheckResult to get all errors,\n       * but if nestedField is used, it is impossible to distinguish whether the nested object has an error here,\n       * so nestedField does not support proxy here\n       */\n\n      if (nestedField) {\n        nextFormError = set(nextFormError, nameToPath(fieldName), resultOfCurrentField);\n        onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n        setFormError(nextFormError);\n        if (resultOfCurrentField.hasError) {\n          onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n        }\n        return resultOfCurrentField;\n      } else {\n        var allResults = model.getCheckResult();\n        var hasError = false;\n        Object.keys(allResults).forEach(function (key) {\n          var currentResult = allResults[key];\n          if (currentResult.hasError) {\n            nextFormError[key] = currentResult.errorMessage || currentResult;\n            hasError = true;\n          } else {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            var _nextFormError2 = nextFormError,\n              _ = _nextFormError2[key],\n              rest = _objectWithoutPropertiesLoose(_nextFormError2, [key].map(_toPropertyKey));\n            nextFormError = rest;\n          }\n        });\n        setFormError(nextFormError);\n        onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);\n        if (hasError) {\n          onError === null || onError === void 0 ? void 0 : onError(nextFormError);\n        }\n        return resultOfCurrentField;\n      }\n    });\n  });\n\n  /**\n   * Asynchronously check form fields and return Promise\n   * @param fieldName\n   */\n  var checkForFieldAsync = useEventCallback(function (fieldName) {\n    return checkFieldAsyncForNextValue(fieldName, formValue || {});\n  });\n  var onRemoveError = useCallback(function (name) {\n    /**\n     * when this function is called when the children component is unmount,\n     * it's an old render frame so use Ref to get future error\n     */\n    var formError = omit(realFormErrorRef.current, [nestedField ? nameToPath(name) : name]);\n    realFormErrorRef.current = formError;\n    setFormError(formError);\n    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);\n    return formError;\n  }, [nestedField, onCheck, setFormError]);\n  var cleanErrors = useEventCallback(function () {\n    setFormError({});\n  });\n  var resetErrors = useEventCallback(function (formError) {\n    if (formError === void 0) {\n      formError = {};\n    }\n    setFormError(formError);\n  });\n  var cleanErrorForField = useEventCallback(function (fieldName) {\n    setFormError(omit(realFormError, [nestedField ? nameToPath(fieldName) : fieldName]));\n  });\n  return {\n    formError: realFormError,\n    check: check,\n    checkForField: checkForField,\n    checkFieldForNextValue: checkFieldForNextValue,\n    checkAsync: checkAsync,\n    checkForFieldAsync: checkForFieldAsync,\n    checkFieldAsyncForNextValue: checkFieldAsyncForNextValue,\n    cleanErrors: cleanErrors,\n    resetErrors: resetErrors,\n    cleanErrorForField: cleanErrorForField,\n    onRemoveError: onRemoveError\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}